(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.default = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _require=_dereq_("./spec/reference-implementation/lib/readable-stream");const ReadableStream=_require.ReadableStream;var _require2=_dereq_("./spec/reference-implementation/lib/writable-stream");const WritableStream=_require2.WritableStream,ByteLengthQueuingStrategy=_dereq_("./spec/reference-implementation/lib/byte-length-queuing-strategy"),CountQueuingStrategy=_dereq_("./spec/reference-implementation/lib/count-queuing-strategy");var _require3=_dereq_("./spec/reference-implementation/lib/transform-stream");const TransformStream=_require3.TransformStream;exports.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy,exports.CountQueuingStrategy=CountQueuingStrategy,exports.ReadableStream=ReadableStream,exports.WritableStream=WritableStream,exports.TransformStream=TransformStream;const interfaces={ReadableStream:ReadableStream,WritableStream:WritableStream,ByteLengthQueuingStrategy:ByteLengthQueuingStrategy,CountQueuingStrategy:CountQueuingStrategy,TransformStream:TransformStream};exports.default=interfaces;

},{"./spec/reference-implementation/lib/byte-length-queuing-strategy":8,"./spec/reference-implementation/lib/count-queuing-strategy":9,"./spec/reference-implementation/lib/readable-stream":12,"./spec/reference-implementation/lib/transform-stream":13,"./spec/reference-implementation/lib/writable-stream":15}],2:[function(_dereq_,module,exports){
(function (global){
"use strict";function compare(t,e){if(t===e)return 0;for(var r=t.length,n=e.length,i=0,a=Math.min(r,n);i<a;++i)if(t[i]!==e[i]){r=t[i],n=e[i];break}return r<n?-1:n<r?1:0}function isBuffer(t){return global.Buffer&&"function"==typeof global.Buffer.isBuffer?global.Buffer.isBuffer(t):!(null==t||!t._isBuffer)}function pToString(t){return Object.prototype.toString.call(t)}function isView(t){return!isBuffer(t)&&("function"==typeof global.ArrayBuffer&&("function"==typeof ArrayBuffer.isView?ArrayBuffer.isView(t):!!t&&(t instanceof DataView||!!(t.buffer&&t.buffer instanceof ArrayBuffer))))}function getName(t){if(util.isFunction(t)){if(functionsHaveNames)return t.name;var e=t.toString().match(regex);return e&&e[1]}}function truncate(t,e){return"string"==typeof t?t.length<e?t:t.slice(0,e):t}function inspect(t){if(functionsHaveNames||!util.isFunction(t))return util.inspect(t);var e=getName(t);return"[Function"+(e?": "+e:"")+"]"}function getMessage(t){return truncate(inspect(t.actual),128)+" "+t.operator+" "+truncate(inspect(t.expected),128)}function fail(t,e,r,n,i){throw new assert.AssertionError({message:r,actual:t,expected:e,operator:n,stackStartFunction:i})}function ok(t,e){t||fail(t,!0,e,"==",assert.ok)}function _deepEqual(t,e,r,n){if(t===e)return!0;if(isBuffer(t)&&isBuffer(e))return 0===compare(t,e);if(util.isDate(t)&&util.isDate(e))return t.getTime()===e.getTime();if(util.isRegExp(t)&&util.isRegExp(e))return t.source===e.source&&t.global===e.global&&t.multiline===e.multiline&&t.lastIndex===e.lastIndex&&t.ignoreCase===e.ignoreCase;if(null!==t&&"object"==typeof t||null!==e&&"object"==typeof e){if(isView(t)&&isView(e)&&pToString(t)===pToString(e)&&!(t instanceof Float32Array||t instanceof Float64Array))return 0===compare(new Uint8Array(t.buffer),new Uint8Array(e.buffer));if(isBuffer(t)!==isBuffer(e))return!1;var i=(n=n||{actual:[],expected:[]}).actual.indexOf(t);return-1!==i&&i===n.expected.indexOf(e)||(n.actual.push(t),n.expected.push(e),objEquiv(t,e,r,n))}return r?t===e:t==e}function isArguments(t){return"[object Arguments]"==Object.prototype.toString.call(t)}function objEquiv(t,e,r,n){if(null===t||void 0===t||null===e||void 0===e)return!1;if(util.isPrimitive(t)||util.isPrimitive(e))return t===e;if(r&&Object.getPrototypeOf(t)!==Object.getPrototypeOf(e))return!1;var i=isArguments(t),a=isArguments(e);if(i&&!a||!i&&a)return!1;if(i)return t=pSlice.call(t),e=pSlice.call(e),_deepEqual(t,e,r);var o,s,u=objectKeys(t),f=objectKeys(e);if(u.length!==f.length)return!1;for(u.sort(),f.sort(),s=u.length-1;s>=0;s--)if(u[s]!==f[s])return!1;for(s=u.length-1;s>=0;s--)if(o=u[s],!_deepEqual(t[o],e[o],r,n))return!1;return!0}function notDeepStrictEqual(t,e,r){_deepEqual(t,e,!0)&&fail(t,e,r,"notDeepStrictEqual",notDeepStrictEqual)}function expectedException(t,e){if(!t||!e)return!1;if("[object RegExp]"==Object.prototype.toString.call(e))return e.test(t);try{if(t instanceof e)return!0}catch(t){}return!Error.isPrototypeOf(e)&&!0===e.call({},t)}function _tryBlock(t){var e;try{t()}catch(t){e=t}return e}function _throws(t,e,r,n){var i;if("function"!=typeof e)throw new TypeError('"block" argument must be a function');"string"==typeof r&&(n=r,r=null),i=_tryBlock(e),n=(r&&r.name?" ("+r.name+").":".")+(n?" "+n:"."),t&&!i&&fail(i,r,"Missing expected exception"+n);var a="string"==typeof n,o=!t&&util.isError(i),s=!t&&i&&!r;if((o&&a&&expectedException(i,r)||s)&&fail(i,r,"Got unwanted exception"+n),t&&i&&r&&!expectedException(i,r)||!t&&i)throw i}var util=_dereq_("util/"),hasOwn=Object.prototype.hasOwnProperty,pSlice=Array.prototype.slice,functionsHaveNames="foo"===function foo(){}.name,assert=module.exports=ok,regex=/\s*function\s+([^\(\s]*)\s*/;assert.AssertionError=function AssertionError(t){this.name="AssertionError",this.actual=t.actual,this.expected=t.expected,this.operator=t.operator,t.message?(this.message=t.message,this.generatedMessage=!1):(this.message=getMessage(this),this.generatedMessage=!0);var e=t.stackStartFunction||fail;if(Error.captureStackTrace)Error.captureStackTrace(this,e);else{var r=new Error;if(r.stack){var n=r.stack,i=getName(e),a=n.indexOf("\n"+i);if(a>=0){var o=n.indexOf("\n",a+1);n=n.substring(o+1)}this.stack=n}}},util.inherits(assert.AssertionError,Error),assert.fail=fail,assert.ok=ok,assert.equal=function equal(t,e,r){t!=e&&fail(t,e,r,"==",assert.equal)},assert.notEqual=function notEqual(t,e,r){t==e&&fail(t,e,r,"!=",assert.notEqual)},assert.deepEqual=function deepEqual(t,e,r){_deepEqual(t,e,!1)||fail(t,e,r,"deepEqual",assert.deepEqual)},assert.deepStrictEqual=function deepStrictEqual(t,e,r){_deepEqual(t,e,!0)||fail(t,e,r,"deepStrictEqual",assert.deepStrictEqual)},assert.notDeepEqual=function notDeepEqual(t,e,r){_deepEqual(t,e,!1)&&fail(t,e,r,"notDeepEqual",assert.notDeepEqual)},assert.notDeepStrictEqual=notDeepStrictEqual,assert.strictEqual=function strictEqual(t,e,r){t!==e&&fail(t,e,r,"===",assert.strictEqual)},assert.notStrictEqual=function notStrictEqual(t,e,r){t===e&&fail(t,e,r,"!==",assert.notStrictEqual)},assert.throws=function(t,e,r){_throws(!0,t,e,r)},assert.doesNotThrow=function(t,e,r){_throws(!1,t,e,r)},assert.ifError=function(t){if(t)throw t};var objectKeys=Object.keys||function(t){var e=[];for(var r in t)hasOwn.call(t,r)&&e.push(r);return e};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"util/":7}],3:[function(_dereq_,module,exports){

},{}],4:[function(_dereq_,module,exports){
function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}function runTimeout(e){if(cachedSetTimeout===setTimeout)return setTimeout(e,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return cachedSetTimeout=setTimeout,setTimeout(e,0);try{return cachedSetTimeout(e,0)}catch(t){try{return cachedSetTimeout.call(null,e,0)}catch(t){return cachedSetTimeout.call(this,e,0)}}}function runClearTimeout(e){if(cachedClearTimeout===clearTimeout)return clearTimeout(e);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return cachedClearTimeout=clearTimeout,clearTimeout(e);try{return cachedClearTimeout(e)}catch(t){try{return cachedClearTimeout.call(null,e)}catch(t){return cachedClearTimeout.call(this,e)}}}function cleanUpNextTick(){draining&&currentQueue&&(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length&&drainQueue())}function drainQueue(){if(!draining){var e=runTimeout(cleanUpNextTick);draining=!0;for(var t=queue.length;t;){for(currentQueue=queue,queue=[];++queueIndex<t;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,t=queue.length}currentQueue=null,draining=!1,runClearTimeout(e)}}function Item(e,t){this.fun=e,this.array=t}function noop(){}var cachedSetTimeout,cachedClearTimeout,process=module.exports={};!function(){try{cachedSetTimeout="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){cachedSetTimeout=defaultSetTimout}try{cachedClearTimeout="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){cachedClearTimeout=defaultClearTimeout}}();var currentQueue,queue=[],draining=!1,queueIndex=-1;process.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];queue.push(new Item(e,t)),1!==queue.length||draining||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},process.title="browser",process.browser=!0,process.env={},process.argv=[],process.version="",process.versions={},process.on=noop,process.addListener=noop,process.once=noop,process.off=noop,process.removeListener=noop,process.removeAllListeners=noop,process.emit=noop,process.prependListener=noop,process.prependOnceListener=noop,process.listeners=function(e){return[]},process.binding=function(e){throw new Error("process.binding is not supported")},process.cwd=function(){return"/"},process.chdir=function(e){throw new Error("process.chdir is not supported")},process.umask=function(){return 0};

},{}],5:[function(_dereq_,module,exports){
"function"==typeof Object.create?module.exports=function inherits(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:module.exports=function inherits(t,e){t.super_=e;var o=function(){};o.prototype=e.prototype,t.prototype=new o,t.prototype.constructor=t};

},{}],6:[function(_dereq_,module,exports){
module.exports=function isBuffer(o){return o&&"object"==typeof o&&"function"==typeof o.copy&&"function"==typeof o.fill&&"function"==typeof o.readUInt8};

},{}],7:[function(_dereq_,module,exports){
(function (process,global){
function inspect(e,r){var t={seen:[],stylize:stylizeNoColor};return arguments.length>=3&&(t.depth=arguments[2]),arguments.length>=4&&(t.colors=arguments[3]),isBoolean(r)?t.showHidden=r:r&&exports._extend(t,r),isUndefined(t.showHidden)&&(t.showHidden=!1),isUndefined(t.depth)&&(t.depth=2),isUndefined(t.colors)&&(t.colors=!1),isUndefined(t.customInspect)&&(t.customInspect=!0),t.colors&&(t.stylize=stylizeWithColor),formatValue(t,e,t.depth)}function stylizeWithColor(e,r){var t=inspect.styles[r];return t?"["+inspect.colors[t][0]+"m"+e+"["+inspect.colors[t][1]+"m":e}function stylizeNoColor(e,r){return e}function arrayToHash(e){var r={};return e.forEach(function(e,t){r[e]=!0}),r}function formatValue(e,r,t){if(e.customInspect&&r&&isFunction(r.inspect)&&r.inspect!==exports.inspect&&(!r.constructor||r.constructor.prototype!==r)){var n=r.inspect(t,e);return isString(n)||(n=formatValue(e,n,t)),n}var i=formatPrimitive(e,r);if(i)return i;var o=Object.keys(r),s=arrayToHash(o);if(e.showHidden&&(o=Object.getOwnPropertyNames(r)),isError(r)&&(o.indexOf("message")>=0||o.indexOf("description")>=0))return formatError(r);if(0===o.length){if(isFunction(r)){var u=r.name?": "+r.name:"";return e.stylize("[Function"+u+"]","special")}if(isRegExp(r))return e.stylize(RegExp.prototype.toString.call(r),"regexp");if(isDate(r))return e.stylize(Date.prototype.toString.call(r),"date");if(isError(r))return formatError(r)}var c="",a=!1,l=["{","}"];if(isArray(r)&&(a=!0,l=["[","]"]),isFunction(r)&&(c=" [Function"+(r.name?": "+r.name:"")+"]"),isRegExp(r)&&(c=" "+RegExp.prototype.toString.call(r)),isDate(r)&&(c=" "+Date.prototype.toUTCString.call(r)),isError(r)&&(c=" "+formatError(r)),0===o.length&&(!a||0==r.length))return l[0]+c+l[1];if(t<0)return isRegExp(r)?e.stylize(RegExp.prototype.toString.call(r),"regexp"):e.stylize("[Object]","special");e.seen.push(r);var p;return p=a?formatArray(e,r,t,s,o):o.map(function(n){return formatProperty(e,r,t,s,n,a)}),e.seen.pop(),reduceToSingleString(p,c,l)}function formatPrimitive(e,r){if(isUndefined(r))return e.stylize("undefined","undefined");if(isString(r)){var t="'"+JSON.stringify(r).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return e.stylize(t,"string")}return isNumber(r)?e.stylize(""+r,"number"):isBoolean(r)?e.stylize(""+r,"boolean"):isNull(r)?e.stylize("null","null"):void 0}function formatError(e){return"["+Error.prototype.toString.call(e)+"]"}function formatArray(e,r,t,n,i){for(var o=[],s=0,u=r.length;s<u;++s)hasOwnProperty(r,String(s))?o.push(formatProperty(e,r,t,n,String(s),!0)):o.push("");return i.forEach(function(i){i.match(/^\d+$/)||o.push(formatProperty(e,r,t,n,i,!0))}),o}function formatProperty(e,r,t,n,i,o){var s,u,c;if((c=Object.getOwnPropertyDescriptor(r,i)||{value:r[i]}).get?u=c.set?e.stylize("[Getter/Setter]","special"):e.stylize("[Getter]","special"):c.set&&(u=e.stylize("[Setter]","special")),hasOwnProperty(n,i)||(s="["+i+"]"),u||(e.seen.indexOf(c.value)<0?(u=isNull(t)?formatValue(e,c.value,null):formatValue(e,c.value,t-1)).indexOf("\n")>-1&&(u=o?u.split("\n").map(function(e){return"  "+e}).join("\n").substr(2):"\n"+u.split("\n").map(function(e){return"   "+e}).join("\n")):u=e.stylize("[Circular]","special")),isUndefined(s)){if(o&&i.match(/^\d+$/))return u;(s=JSON.stringify(""+i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(s=s.substr(1,s.length-2),s=e.stylize(s,"name")):(s=s.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),s=e.stylize(s,"string"))}return s+": "+u}function reduceToSingleString(e,r,t){var n=0;return e.reduce(function(e,r){return n++,r.indexOf("\n")>=0&&n++,e+r.replace(/\u001b\[\d\d?m/g,"").length+1},0)>60?t[0]+(""===r?"":r+"\n ")+" "+e.join(",\n  ")+" "+t[1]:t[0]+r+" "+e.join(", ")+" "+t[1]}function isArray(e){return Array.isArray(e)}function isBoolean(e){return"boolean"==typeof e}function isNull(e){return null===e}function isNullOrUndefined(e){return null==e}function isNumber(e){return"number"==typeof e}function isString(e){return"string"==typeof e}function isSymbol(e){return"symbol"==typeof e}function isUndefined(e){return void 0===e}function isRegExp(e){return isObject(e)&&"[object RegExp]"===objectToString(e)}function isObject(e){return"object"==typeof e&&null!==e}function isDate(e){return isObject(e)&&"[object Date]"===objectToString(e)}function isError(e){return isObject(e)&&("[object Error]"===objectToString(e)||e instanceof Error)}function isFunction(e){return"function"==typeof e}function isPrimitive(e){return null===e||"boolean"==typeof e||"number"==typeof e||"string"==typeof e||"symbol"==typeof e||void 0===e}function objectToString(e){return Object.prototype.toString.call(e)}function pad(e){return e<10?"0"+e.toString(10):e.toString(10)}function timestamp(){var e=new Date,r=[pad(e.getHours()),pad(e.getMinutes()),pad(e.getSeconds())].join(":");return[e.getDate(),months[e.getMonth()],r].join(" ")}function hasOwnProperty(e,r){return Object.prototype.hasOwnProperty.call(e,r)}var formatRegExp=/%[sdj%]/g;exports.format=function(e){if(!isString(e)){for(var r=[],t=0;t<arguments.length;t++)r.push(inspect(arguments[t]));return r.join(" ")}for(var t=1,n=arguments,i=n.length,o=String(e).replace(formatRegExp,function(e){if("%%"===e)return"%";if(t>=i)return e;switch(e){case"%s":return String(n[t++]);case"%d":return Number(n[t++]);case"%j":try{return JSON.stringify(n[t++])}catch(e){return"[Circular]"}default:return e}}),s=n[t];t<i;s=n[++t])isNull(s)||!isObject(s)?o+=" "+s:o+=" "+inspect(s);return o},exports.deprecate=function(e,r){if(isUndefined(global.process))return function(){return exports.deprecate(e,r).apply(this,arguments)};if(!0===process.noDeprecation)return e;var t=!1;return function deprecated(){if(!t){if(process.throwDeprecation)throw new Error(r);process.traceDeprecation?console.trace(r):console.error(r),t=!0}return e.apply(this,arguments)}};var debugEnviron,debugs={};exports.debuglog=function(e){if(isUndefined(debugEnviron)&&(debugEnviron=process.env.NODE_DEBUG||""),e=e.toUpperCase(),!debugs[e])if(new RegExp("\\b"+e+"\\b","i").test(debugEnviron)){var r=process.pid;debugs[e]=function(){var t=exports.format.apply(exports,arguments);console.error("%s %d: %s",e,r,t)}}else debugs[e]=function(){};return debugs[e]},exports.inspect=inspect,inspect.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},inspect.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"},exports.isArray=isArray,exports.isBoolean=isBoolean,exports.isNull=isNull,exports.isNullOrUndefined=isNullOrUndefined,exports.isNumber=isNumber,exports.isString=isString,exports.isSymbol=isSymbol,exports.isUndefined=isUndefined,exports.isRegExp=isRegExp,exports.isObject=isObject,exports.isDate=isDate,exports.isError=isError,exports.isFunction=isFunction,exports.isPrimitive=isPrimitive,exports.isBuffer=_dereq_("./support/isBuffer");var months=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];exports.log=function(){console.log("%s - %s",timestamp(),exports.format.apply(exports,arguments))},exports.inherits=_dereq_("inherits"),exports._extend=function(e,r){if(!r||!isObject(r))return e;for(var t=Object.keys(r),n=t.length;n--;)e[t[n]]=r[t[n]];return e};

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":6,"_process":4,"inherits":5}],8:[function(_dereq_,module,exports){
"use strict";var _require=_dereq_("./helpers.js");const createDataProperty=_require.createDataProperty;module.exports=class ByteLengthQueuingStrategy{constructor({highWaterMark:r}){createDataProperty(this,"highWaterMark",r)}size(r){return r.byteLength}};

},{"./helpers.js":10}],9:[function(_dereq_,module,exports){
"use strict";var _require=_dereq_("./helpers.js");const createDataProperty=_require.createDataProperty;module.exports=class CountQueuingStrategy{constructor({highWaterMark:r}){createDataProperty(this,"highWaterMark",r)}size(){return 1}};

},{"./helpers.js":10}],10:[function(_dereq_,module,exports){
"use strict";function IsPropertyKey(e){return"string"==typeof e||"symbol"==typeof e}function Call(e,r,t){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,r,t)}function PromiseCall(e,r,t){try{return Promise.resolve(Call(e,r,t))}catch(e){return Promise.reject(e)}}const assert=_dereq_("better-assert"),isFakeDetached=Symbol('is "detached" for our purposes');exports.typeIsObject=(e=>"object"==typeof e&&null!==e||"function"==typeof e),exports.createDataProperty=((e,r,t)=>{Object.defineProperty(e,r,{value:t,writable:!0,enumerable:!0,configurable:!0})}),exports.createArrayFromList=(e=>e.slice()),exports.ArrayBufferCopy=((e,r,t,o,n)=>{new Uint8Array(e).set(new Uint8Array(t,o,n),r)}),exports.CreateIterResultObject=((e,r)=>{const t={};return Object.defineProperty(t,"value",{value:e,enumerable:!0,writable:!0,configurable:!0}),Object.defineProperty(t,"done",{value:r,enumerable:!0,writable:!0,configurable:!0}),t}),exports.IsFiniteNonNegativeNumber=(e=>!1!==exports.IsNonNegativeNumber(e)&&e!==1/0),exports.IsNonNegativeNumber=(e=>"number"==typeof e&&(!Number.isNaN(e)&&!(e<0))),exports.Call=Call,exports.CreateAlgorithmFromUnderlyingMethod=((e,r,t,o)=>{const n=e[r];if(void 0!==n){if("function"!=typeof n)throw new TypeError(`${n} is not a method`);switch(t){case 0:return()=>PromiseCall(n,e,o);case 1:return r=>{const t=[r].concat(o);return PromiseCall(n,e,t)}}}return()=>Promise.resolve()}),exports.InvokeOrNoop=((e,r,t)=>{const o=e[r];if(void 0!==o)return Call(o,e,t)}),exports.PromiseCall=PromiseCall,exports.TransferArrayBuffer=(e=>{const r=e.slice();return Object.defineProperty(e,"byteLength",{get:()=>0}),e[isFakeDetached]=!0,r}),exports.IsDetachedBuffer=(e=>isFakeDetached in e),exports.ValidateAndNormalizeHighWaterMark=(e=>{if(e=Number(e),Number.isNaN(e)||e<0)throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");return e}),exports.MakeSizeAlgorithmFromSizeFunction=(e=>{if(void 0===e)return()=>1;if("function"!=typeof e)throw new TypeError("size property of a queuing strategy must be a function");return r=>e(r)});

},{"better-assert":16}],11:[function(_dereq_,module,exports){
"use strict";const assert=_dereq_("better-assert");var _require=_dereq_("./helpers.js");const IsFiniteNonNegativeNumber=_require.IsFiniteNonNegativeNumber;exports.DequeueValue=(e=>{const u=e._queue.shift();return e._queueTotalSize-=u.size,e._queueTotalSize<0&&(e._queueTotalSize=0),u.value}),exports.EnqueueValueWithSize=((e,u,t)=>{if(t=Number(t),!IsFiniteNonNegativeNumber(t))throw new RangeError("Size must be a finite, non-NaN, non-negative number.");e._queue.push({value:u,size:t}),e._queueTotalSize+=t}),exports.PeekQueueValue=(e=>e._queue[0].value),exports.ResetQueue=(e=>{e._queue=[],e._queueTotalSize=0});

},{"./helpers.js":10,"better-assert":16}],12:[function(_dereq_,module,exports){
"use strict";function AcquireReadableStreamBYOBReader(e){return new ReadableStreamBYOBReader(e)}function AcquireReadableStreamDefaultReader(e){return new ReadableStreamDefaultReader(e)}function CreateReadableStream(e,r,t,a=1,l=(()=>1)){const o=Object.create(ReadableStream.prototype);return InitializeReadableStream(o),SetUpReadableStreamDefaultController(o,Object.create(ReadableStreamDefaultController.prototype),e,r,t,a,l),o}function CreateReadableByteStream(e,r,t,a=0,l){const o=Object.create(ReadableStream.prototype);return InitializeReadableStream(o),SetUpReadableByteStreamController(o,Object.create(ReadableByteStreamController.prototype),e,r,t,a,l),o}function InitializeReadableStream(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function IsReadableStream(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")}function IsReadableStreamDisturbed(e){return e._disturbed}function IsReadableStreamLocked(e){return void 0!==e._reader}function ReadableStreamTee(e,r){function pullAlgorithm(){return ReadableStreamDefaultReaderRead(t).then(e=>{const r=e.value;if(!0===e.done&&!1===d&&(!1===i&&ReadableStreamDefaultControllerClose(o._readableStreamController),!1===u&&ReadableStreamDefaultControllerClose(n._readableStreamController),d=!0),!0===d)return;const t=r,a=r;!1===i&&ReadableStreamDefaultControllerEnqueue(o._readableStreamController,t),!1===u&&ReadableStreamDefaultControllerEnqueue(n._readableStreamController,a)})}function startAlgorithm(){}const t=AcquireReadableStreamDefaultReader(e);let a,l,o,n,s,d=!1,i=!1,u=!1;const c=new Promise(e=>{s=e});return o=CreateReadableStream(startAlgorithm,pullAlgorithm,function cancel1Algorithm(r){if(i=!0,a=r,!0===u){const r=createArrayFromList([a,l]),t=ReadableStreamCancel(e,r);s(t)}return c}),n=CreateReadableStream(startAlgorithm,pullAlgorithm,function cancel2Algorithm(r){if(u=!0,l=r,!0===i){const r=createArrayFromList([a,l]),t=ReadableStreamCancel(e,r);s(t)}return c}),t._closedPromise.catch(e=>{!0!==d&&(ReadableStreamDefaultControllerErrorIfNeeded(o._readableStreamController,e),ReadableStreamDefaultControllerErrorIfNeeded(n._readableStreamController,e),d=!0)}),[o,n]}function ReadableStreamAddReadIntoRequest(e){return new Promise((r,t)=>{const a={_resolve:r,_reject:t};e._reader._readIntoRequests.push(a)})}function ReadableStreamAddReadRequest(e){return new Promise((r,t)=>{const a={_resolve:r,_reject:t};e._reader._readRequests.push(a)})}function ReadableStreamCancel(e,r){return e._disturbed=!0,"closed"===e._state?Promise.resolve(void 0):"errored"===e._state?Promise.reject(e._storedError):(ReadableStreamClose(e),e._readableStreamController[CancelSteps](r).then(()=>void 0))}function ReadableStreamClose(e){e._state="closed";const r=e._reader;if(void 0!==r){if(!0===IsReadableStreamDefaultReader(r)){for(const e of r._readRequests)(0,e._resolve)(CreateIterResultObject(void 0,!0));r._readRequests=[]}defaultReaderClosedPromiseResolve(r)}}function ReadableStreamError(e,r){e._state="errored",e._storedError=r;const t=e._reader;if(void 0!==t){if(!0===IsReadableStreamDefaultReader(t)){for(const e of t._readRequests)e._reject(r);t._readRequests=[]}else{for(const e of t._readIntoRequests)e._reject(r);t._readIntoRequests=[]}defaultReaderClosedPromiseReject(t,r),t._closedPromise.catch(()=>{})}}function ReadableStreamFulfillReadIntoRequest(e,r,t){e._reader._readIntoRequests.shift()._resolve(CreateIterResultObject(r,t))}function ReadableStreamFulfillReadRequest(e,r,t){e._reader._readRequests.shift()._resolve(CreateIterResultObject(r,t))}function ReadableStreamGetNumReadIntoRequests(e){return e._reader._readIntoRequests.length}function ReadableStreamGetNumReadRequests(e){return e._reader._readRequests.length}function ReadableStreamHasBYOBReader(e){const r=e._reader;return void 0!==r&&!1!==IsReadableStreamBYOBReader(r)}function ReadableStreamHasDefaultReader(e){const r=e._reader;return void 0!==r&&!1!==IsReadableStreamDefaultReader(r)}function IsReadableStreamBYOBReader(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")}function IsReadableStreamDefaultReader(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_readRequests")}function ReadableStreamReaderGenericInitialize(e,r){e._ownerReadableStream=r,r._reader=e,"readable"===r._state?defaultReaderClosedPromiseInitialize(e):"closed"===r._state?defaultReaderClosedPromiseInitializeAsResolved(e):(defaultReaderClosedPromiseInitializeAsRejected(e,r._storedError),e._closedPromise.catch(()=>{}))}function ReadableStreamReaderGenericCancel(e,r){return ReadableStreamCancel(e._ownerReadableStream,r)}function ReadableStreamReaderGenericRelease(e){"readable"===e._ownerReadableStream._state?defaultReaderClosedPromiseReject(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):defaultReaderClosedPromiseResetToRejected(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._closedPromise.catch(()=>{}),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function ReadableStreamBYOBReaderRead(e,r){const t=e._ownerReadableStream;return t._disturbed=!0,"errored"===t._state?Promise.reject(t._storedError):ReadableByteStreamControllerPullInto(t._readableStreamController,r)}function ReadableStreamDefaultReaderRead(e){const r=e._ownerReadableStream;return r._disturbed=!0,"closed"===r._state?Promise.resolve(CreateIterResultObject(void 0,!0)):"errored"===r._state?Promise.reject(r._storedError):r._readableStreamController[PullSteps]()}function IsReadableStreamDefaultController(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")}function ReadableStreamDefaultControllerCallPullIfNeeded(e){!1!==ReadableStreamDefaultControllerShouldCallPull(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{if(e._pulling=!1,!0===e._pullAgain)return e._pullAgain=!1,ReadableStreamDefaultControllerCallPullIfNeeded(e)},r=>{ReadableStreamDefaultControllerErrorIfNeeded(e,r)}).catch(rethrowAssertionErrorRejection)):e._pullAgain=!0)}function ReadableStreamDefaultControllerShouldCallPull(e){const r=e._controlledReadableStream;return!1!==ReadableStreamDefaultControllerCanCloseOrEnqueue(e)&&(!1!==e._started&&(!0===IsReadableStreamLocked(r)&&ReadableStreamGetNumReadRequests(r)>0||ReadableStreamDefaultControllerGetDesiredSize(e)>0))}function ReadableStreamDefaultControllerClose(e){const r=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&ReadableStreamClose(r)}function ReadableStreamDefaultControllerEnqueue(e,r){const t=e._controlledReadableStream;if(!0===IsReadableStreamLocked(t)&&ReadableStreamGetNumReadRequests(t)>0)ReadableStreamFulfillReadRequest(t,r,!1);else{let t;try{t=e._strategySizeAlgorithm(r)}catch(r){throw ReadableStreamDefaultControllerErrorIfNeeded(e,r),r}try{EnqueueValueWithSize(e,r,t)}catch(r){throw ReadableStreamDefaultControllerErrorIfNeeded(e,r),r}}ReadableStreamDefaultControllerCallPullIfNeeded(e)}function ReadableStreamDefaultControllerError(e,r){const t=e._controlledReadableStream;ResetQueue(e),ReadableStreamError(t,r)}function ReadableStreamDefaultControllerErrorIfNeeded(e,r){"readable"===e._controlledReadableStream._state&&ReadableStreamDefaultControllerError(e,r)}function ReadableStreamDefaultControllerGetDesiredSize(e){const r=e._controlledReadableStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function ReadableStreamDefaultControllerHasBackpressure(e){return!0!==ReadableStreamDefaultControllerShouldCallPull(e)}function ReadableStreamDefaultControllerCanCloseOrEnqueue(e){const r=e._controlledReadableStream._state;return!1===e._closeRequested&&"readable"===r}function SetUpReadableStreamDefaultController(e,r,t,a,l,o,n){r._controlledReadableStream=e,r._queue=void 0,r._queueTotalSize=void 0,ResetQueue(r),r._started=!1,r._closeRequested=!1,r._pullAgain=!1,r._pulling=!1,r._strategySizeAlgorithm=n,r._strategyHWM=o,r._pullAlgorithm=a,r._cancelAlgorithm=l,e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,ReadableStreamDefaultControllerCallPullIfNeeded(r)},e=>{ReadableStreamDefaultControllerErrorIfNeeded(r,e)}).catch(rethrowAssertionErrorRejection)}function SetUpReadableStreamDefaultControllerFromUnderlyingSource(e,r,t,a){const l=Object.create(ReadableStreamDefaultController.prototype),o=CreateAlgorithmFromUnderlyingMethod(r,"pull",0,[l]),n=CreateAlgorithmFromUnderlyingMethod(r,"cancel",1,[]);SetUpReadableStreamDefaultController(e,l,function startAlgorithm(){return InvokeOrNoop(r,"start",[l])},o,n,t,a)}function IsReadableByteStreamController(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")}function IsReadableStreamBYOBRequest(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")}function ReadableByteStreamControllerCallPullIfNeeded(e){!1!==ReadableByteStreamControllerShouldCallPull(e)&&(!0!==e._pulling?(e._pulling=!0,e._pullAlgorithm().then(()=>{e._pulling=!1,!0===e._pullAgain&&(e._pullAgain=!1,ReadableByteStreamControllerCallPullIfNeeded(e))},r=>{"readable"===e._controlledReadableByteStream._state&&ReadableByteStreamControllerError(e,r)}).catch(rethrowAssertionErrorRejection)):e._pullAgain=!0)}function ReadableByteStreamControllerClearPendingPullIntos(e){ReadableByteStreamControllerInvalidateBYOBRequest(e),e._pendingPullIntos=[]}function ReadableByteStreamControllerCommitPullIntoDescriptor(e,r){let t=!1;"closed"===e._state&&(t=!0);const a=ReadableByteStreamControllerConvertPullIntoDescriptor(r);"default"===r.readerType?ReadableStreamFulfillReadRequest(e,a,t):ReadableStreamFulfillReadIntoRequest(e,a,t)}function ReadableByteStreamControllerConvertPullIntoDescriptor(e){const r=e.bytesFilled,t=e.elementSize;return new e.ctor(e.buffer,e.byteOffset,r/t)}function ReadableByteStreamControllerEnqueueChunkToQueue(e,r,t,a){e._queue.push({buffer:r,byteOffset:t,byteLength:a}),e._queueTotalSize+=a}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(e,r){const t=r.elementSize,a=r.bytesFilled-r.bytesFilled%t,l=Math.min(e._queueTotalSize,r.byteLength-r.bytesFilled),o=r.bytesFilled+l,n=o-o%t;let s=l,d=!1;n>a&&(s=n-r.bytesFilled,d=!0);const i=e._queue;for(;s>0;){const t=i[0],a=Math.min(s,t.byteLength),l=r.byteOffset+r.bytesFilled;ArrayBufferCopy(r.buffer,l,t.buffer,t.byteOffset,a),t.byteLength===a?i.shift():(t.byteOffset+=a,t.byteLength-=a),e._queueTotalSize-=a,ReadableByteStreamControllerFillHeadPullIntoDescriptor(e,a,r),s-=a}return d}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(e,r,t){ReadableByteStreamControllerInvalidateBYOBRequest(e),t.bytesFilled+=r}function ReadableByteStreamControllerHandleQueueDrain(e){0===e._queueTotalSize&&!0===e._closeRequested?ReadableStreamClose(e._controlledReadableByteStream):ReadableByteStreamControllerCallPullIfNeeded(e)}function ReadableByteStreamControllerInvalidateBYOBRequest(e){void 0!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=void 0,e._byobRequest=void 0)}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const r=e._pendingPullIntos[0];!0===ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(e,r)&&(ReadableByteStreamControllerShiftPendingPullInto(e),ReadableByteStreamControllerCommitPullIntoDescriptor(e._controlledReadableByteStream,r))}}function ReadableByteStreamControllerPullInto(e,r){const t=e._controlledReadableByteStream;let a=1;r.constructor!==DataView&&(a=r.constructor.BYTES_PER_ELEMENT);const l=r.constructor,o={buffer:TransferArrayBuffer(r.buffer),byteOffset:r.byteOffset,byteLength:r.byteLength,bytesFilled:0,elementSize:a,ctor:l,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(o),ReadableStreamAddReadIntoRequest(t);if("closed"===t._state){const e=new r.constructor(o.buffer,o.byteOffset,0);return Promise.resolve(CreateIterResultObject(e,!0))}if(e._queueTotalSize>0){if(!0===ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(e,o)){const r=ReadableByteStreamControllerConvertPullIntoDescriptor(o);return ReadableByteStreamControllerHandleQueueDrain(e),Promise.resolve(CreateIterResultObject(r,!1))}if(!0===e._closeRequested){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");return ReadableByteStreamControllerError(e,r),Promise.reject(r)}}e._pendingPullIntos.push(o);const n=ReadableStreamAddReadIntoRequest(t);return ReadableByteStreamControllerCallPullIfNeeded(e),n}function ReadableByteStreamControllerRespondInClosedState(e,r){r.buffer=TransferArrayBuffer(r.buffer);const t=e._controlledReadableByteStream;if(!0===ReadableStreamHasBYOBReader(t))for(;ReadableStreamGetNumReadIntoRequests(t)>0;)ReadableByteStreamControllerCommitPullIntoDescriptor(t,ReadableByteStreamControllerShiftPendingPullInto(e))}function ReadableByteStreamControllerRespondInReadableState(e,r,t){if(t.bytesFilled+r>t.byteLength)throw new RangeError("bytesWritten out of range");if(ReadableByteStreamControllerFillHeadPullIntoDescriptor(e,r,t),t.bytesFilled<t.elementSize)return;ReadableByteStreamControllerShiftPendingPullInto(e);const a=t.bytesFilled%t.elementSize;if(a>0){const r=t.byteOffset+t.bytesFilled,l=t.buffer.slice(r-a,r);ReadableByteStreamControllerEnqueueChunkToQueue(e,l,0,l.byteLength)}t.buffer=TransferArrayBuffer(t.buffer),t.bytesFilled-=a,ReadableByteStreamControllerCommitPullIntoDescriptor(e._controlledReadableByteStream,t),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e)}function ReadableByteStreamControllerRespondInternal(e,r){const t=e._pendingPullIntos[0];if("closed"===e._controlledReadableByteStream._state){if(0!==r)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");ReadableByteStreamControllerRespondInClosedState(e,t)}else ReadableByteStreamControllerRespondInReadableState(e,r,t)}function ReadableByteStreamControllerShiftPendingPullInto(e){const r=e._pendingPullIntos.shift();return ReadableByteStreamControllerInvalidateBYOBRequest(e),r}function ReadableByteStreamControllerShouldCallPull(e){const r=e._controlledReadableByteStream;return"readable"===r._state&&(!0!==e._closeRequested&&(!1!==e._started&&(!0===ReadableStreamHasDefaultReader(r)&&ReadableStreamGetNumReadRequests(r)>0||(!0===ReadableStreamHasBYOBReader(r)&&ReadableStreamGetNumReadIntoRequests(r)>0||ReadableByteStreamControllerGetDesiredSize(e)>0))))}function ReadableByteStreamControllerClose(e){const r=e._controlledReadableByteStream;if(e._queueTotalSize>0)e._closeRequested=!0;else{if(e._pendingPullIntos.length>0&&e._pendingPullIntos[0].bytesFilled>0){const r=new TypeError("Insufficient bytes to fill elements in the given buffer");throw ReadableByteStreamControllerError(e,r),r}ReadableStreamClose(r)}}function ReadableByteStreamControllerEnqueue(e,r){const t=e._controlledReadableByteStream,a=r.buffer,l=r.byteOffset,o=r.byteLength,n=TransferArrayBuffer(a);!0===ReadableStreamHasDefaultReader(t)?0===ReadableStreamGetNumReadRequests(t)?ReadableByteStreamControllerEnqueueChunkToQueue(e,n,l,o):ReadableStreamFulfillReadRequest(t,new Uint8Array(n,l,o),!1):!0===ReadableStreamHasBYOBReader(t)?(ReadableByteStreamControllerEnqueueChunkToQueue(e,n,l,o),ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(e)):ReadableByteStreamControllerEnqueueChunkToQueue(e,n,l,o)}function ReadableByteStreamControllerError(e,r){const t=e._controlledReadableByteStream;ReadableByteStreamControllerClearPendingPullIntos(e),ResetQueue(e),ReadableStreamError(t,r)}function ReadableByteStreamControllerGetDesiredSize(e){const r=e._controlledReadableByteStream._state;return"errored"===r?null:"closed"===r?0:e._strategyHWM-e._queueTotalSize}function ReadableByteStreamControllerRespond(e,r){if(r=Number(r),!1===IsFiniteNonNegativeNumber(r))throw new RangeError("bytesWritten must be a finite");ReadableByteStreamControllerRespondInternal(e,r)}function ReadableByteStreamControllerRespondWithNewView(e,r){const t=e._pendingPullIntos[0];if(t.byteOffset+t.bytesFilled!==r.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(t.byteLength!==r.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");t.buffer=r.buffer,ReadableByteStreamControllerRespondInternal(e,r.byteLength)}function SetUpReadableByteStreamController(e,r,t,a,l,o,n){r._controlledReadableByteStream=e,r._pullAgain=!1,r._pulling=!1,ReadableByteStreamControllerClearPendingPullIntos(r),r._queue=r._queueTotalSize=void 0,ResetQueue(r),r._closeRequested=!1,r._started=!1,r._strategyHWM=ValidateAndNormalizeHighWaterMark(o),r._pullAlgorithm=a,r._cancelAlgorithm=l,r._autoAllocateChunkSize=n,r._pendingPullIntos=[],e._readableStreamController=r;const s=t();Promise.resolve(s).then(()=>{r._started=!0,ReadableByteStreamControllerCallPullIfNeeded(r)},t=>{"readable"===e._state&&ReadableByteStreamControllerError(r,t)}).catch(rethrowAssertionErrorRejection)}function SetUpReadableByteStreamControllerFromUnderlyingSource(e,r,t){const a=Object.create(ReadableByteStreamController.prototype),l=CreateAlgorithmFromUnderlyingMethod(r,"pull",0,[a]),o=CreateAlgorithmFromUnderlyingMethod(r,"cancel",1,[]),n=r.autoAllocateChunkSize;if(void 0!==n&&(!1===Number.isInteger(n)||n<=0))throw new RangeError("autoAllocateChunkSize must be a positive integer");SetUpReadableByteStreamController(e,a,function startAlgorithm(){return InvokeOrNoop(r,"start",[a])},l,o,t,n)}function SetUpReadableStreamBYOBRequest(e,r,t){e._associatedReadableByteStreamController=r,e._view=t}function streamBrandCheckException(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function readerLockException(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function defaultReaderBrandCheckException(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}function defaultReaderClosedPromiseInitialize(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t})}function defaultReaderClosedPromiseInitializeAsRejected(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function defaultReaderClosedPromiseInitializeAsResolved(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function defaultReaderClosedPromiseReject(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function defaultReaderClosedPromiseResetToRejected(e,r){e._closedPromise=Promise.reject(r)}function defaultReaderClosedPromiseResolve(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0}function byobReaderBrandCheckException(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function defaultControllerBrandCheckException(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function byobRequestBrandCheckException(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(e){try{Promise.prototype.then.call(e,void 0,()=>{})}catch(e){}}const assert=_dereq_("better-assert");var _require=_dereq_("./helpers.js");const ArrayBufferCopy=_require.ArrayBufferCopy,CreateAlgorithmFromUnderlyingMethod=_require.CreateAlgorithmFromUnderlyingMethod,CreateIterResultObject=_require.CreateIterResultObject,IsFiniteNonNegativeNumber=_require.IsFiniteNonNegativeNumber,InvokeOrNoop=_require.InvokeOrNoop,IsDetachedBuffer=_require.IsDetachedBuffer,TransferArrayBuffer=_require.TransferArrayBuffer,ValidateAndNormalizeHighWaterMark=_require.ValidateAndNormalizeHighWaterMark,IsNonNegativeNumber=_require.IsNonNegativeNumber,MakeSizeAlgorithmFromSizeFunction=_require.MakeSizeAlgorithmFromSizeFunction,createArrayFromList=_require.createArrayFromList,typeIsObject=_require.typeIsObject;var _require2=_dereq_("./utils.js");const rethrowAssertionErrorRejection=_require2.rethrowAssertionErrorRejection;var _require3=_dereq_("./queue-with-sizes.js");const DequeueValue=_require3.DequeueValue,EnqueueValueWithSize=_require3.EnqueueValueWithSize,ResetQueue=_require3.ResetQueue;var _require4=_dereq_("./writable-stream.js");const AcquireWritableStreamDefaultWriter=_require4.AcquireWritableStreamDefaultWriter,IsWritableStream=_require4.IsWritableStream,IsWritableStreamLocked=_require4.IsWritableStreamLocked,WritableStreamAbort=_require4.WritableStreamAbort,WritableStreamDefaultWriterCloseWithErrorPropagation=_require4.WritableStreamDefaultWriterCloseWithErrorPropagation,WritableStreamDefaultWriterRelease=_require4.WritableStreamDefaultWriterRelease,WritableStreamDefaultWriterWrite=_require4.WritableStreamDefaultWriterWrite,WritableStreamCloseQueuedOrInFlight=_require4.WritableStreamCloseQueuedOrInFlight,CancelSteps=Symbol("[[CancelSteps]]"),PullSteps=Symbol("[[PullSteps]]");class ReadableStream{constructor(e={},{size:r,highWaterMark:t}={}){InitializeReadableStream(this);const a=e.type;if("bytes"===String(a)){if(void 0===t&&(t=0),t=ValidateAndNormalizeHighWaterMark(t),void 0!==r)throw new RangeError("The strategy for a byte stream cannot have a size function");SetUpReadableByteStreamControllerFromUnderlyingSource(this,e,t)}else{if(void 0!==a)throw new RangeError("Invalid type is specified");void 0===t&&(t=1),SetUpReadableStreamDefaultControllerFromUnderlyingSource(this,e,t=ValidateAndNormalizeHighWaterMark(t),MakeSizeAlgorithmFromSizeFunction(r))}}get locked(){if(!1===IsReadableStream(this))throw streamBrandCheckException("locked");return IsReadableStreamLocked(this)}cancel(e){return!1===IsReadableStream(this)?Promise.reject(streamBrandCheckException("cancel")):!0===IsReadableStreamLocked(this)?Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")):ReadableStreamCancel(this,e)}getReader({mode:e}={}){if(!1===IsReadableStream(this))throw streamBrandCheckException("getReader");if(void 0===e)return AcquireReadableStreamDefaultReader(this);if("byob"===(e=String(e)))return AcquireReadableStreamBYOBReader(this);throw new RangeError("Invalid mode is specified")}pipeThrough({writable:e,readable:r},t){if(void 0===e||void 0===r)throw new TypeError("readable and writable arguments must be defined");return ifIsObjectAndHasAPromiseIsHandledInternalSlotSetPromiseIsHandledToTrue(this.pipeTo(e,t)),r}pipeTo(e,{preventClose:r,preventAbort:t,preventCancel:a}={}){if(!1===IsReadableStream(this))return Promise.reject(streamBrandCheckException("pipeTo"));if(!1===IsWritableStream(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));if(r=Boolean(r),t=Boolean(t),a=Boolean(a),!0===IsReadableStreamLocked(this))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));if(!0===IsWritableStreamLocked(e))return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));const l=AcquireReadableStreamDefaultReader(this),o=AcquireWritableStreamDefaultWriter(e);let n=!1,s=Promise.resolve();return new Promise((d,i)=>{function pipeLoop(){return!0===n?Promise.resolve():o._readyPromise.then(()=>ReadableStreamDefaultReaderRead(l).then(({value:e,done:r})=>{!0!==r&&(s=WritableStreamDefaultWriterWrite(o,e).catch(()=>{}))})).then(pipeLoop)}function waitForWritesToFinish(){const e=s;return s.then(()=>e!==s?waitForWritesToFinish():void 0)}function isOrBecomesErrored(e,r,t){"errored"===e._state?t(e._storedError):r.catch(t).catch(rethrowAssertionErrorRejection)}function shutdownWithAction(r,t,a){function doTheRest(){r().then(()=>finalize(t,a),e=>finalize(!0,e)).catch(rethrowAssertionErrorRejection)}!0!==n&&(n=!0,"writable"===e._state&&!1===WritableStreamCloseQueuedOrInFlight(e)?waitForWritesToFinish().then(doTheRest):doTheRest())}function shutdown(r,t){!0!==n&&(n=!0,"writable"===e._state&&!1===WritableStreamCloseQueuedOrInFlight(e)?waitForWritesToFinish().then(()=>finalize(r,t)).catch(rethrowAssertionErrorRejection):finalize(r,t))}function finalize(e,r){WritableStreamDefaultWriterRelease(o),ReadableStreamReaderGenericRelease(l),e?i(r):d(void 0)}if(isOrBecomesErrored(this,l._closedPromise,r=>{!1===t?shutdownWithAction(()=>WritableStreamAbort(e,r),!0,r):shutdown(!0,r)}),isOrBecomesErrored(e,o._closedPromise,e=>{!1===a?shutdownWithAction(()=>ReadableStreamCancel(this,e),!0,e):shutdown(!0,e)}),function isOrBecomesClosed(e,r,t){"closed"===e._state?t():r.then(t).catch(rethrowAssertionErrorRejection)}(this,l._closedPromise,()=>{!1===r?shutdownWithAction(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(o)):shutdown()}),!0===WritableStreamCloseQueuedOrInFlight(e)||"closed"===e._state){const e=new TypeError("the destination writable stream closed before all data could be piped to it");!1===a?shutdownWithAction(()=>ReadableStreamCancel(this,e),!0,e):shutdown(!0,e)}pipeLoop().catch(e=>{s=Promise.resolve(),rethrowAssertionErrorRejection(e)})})}tee(){if(!1===IsReadableStream(this))throw streamBrandCheckException("tee");const e=ReadableStreamTee(this,!1);return createArrayFromList(e)}}module.exports={CreateReadableByteStream:CreateReadableByteStream,CreateReadableStream:CreateReadableStream,ReadableStream:ReadableStream,IsReadableStreamDisturbed:IsReadableStreamDisturbed,ReadableStreamDefaultControllerClose:ReadableStreamDefaultControllerClose,ReadableStreamDefaultControllerEnqueue:ReadableStreamDefaultControllerEnqueue,ReadableStreamDefaultControllerError:ReadableStreamDefaultControllerError,ReadableStreamDefaultControllerGetDesiredSize:ReadableStreamDefaultControllerGetDesiredSize,ReadableStreamDefaultControllerHasBackpressure:ReadableStreamDefaultControllerHasBackpressure,ReadableStreamDefaultControllerCanCloseOrEnqueue:ReadableStreamDefaultControllerCanCloseOrEnqueue};class ReadableStreamDefaultReader{constructor(e){if(!1===IsReadableStream(e))throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");if(!0===IsReadableStreamLocked(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,e),this._readRequests=[]}get closed(){return!1===IsReadableStreamDefaultReader(this)?Promise.reject(defaultReaderBrandCheckException("closed")):this._closedPromise}cancel(e){return!1===IsReadableStreamDefaultReader(this)?Promise.reject(defaultReaderBrandCheckException("cancel")):void 0===this._ownerReadableStream?Promise.reject(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,e)}read(){return!1===IsReadableStreamDefaultReader(this)?Promise.reject(defaultReaderBrandCheckException("read")):void 0===this._ownerReadableStream?Promise.reject(readerLockException("read from")):ReadableStreamDefaultReaderRead(this)}releaseLock(){if(!1===IsReadableStreamDefaultReader(this))throw defaultReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}}class ReadableStreamBYOBReader{constructor(e){if(!IsReadableStream(e))throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");if(!1===IsReadableByteStreamController(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");if(IsReadableStreamLocked(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");ReadableStreamReaderGenericInitialize(this,e),this._readIntoRequests=[]}get closed(){return IsReadableStreamBYOBReader(this)?this._closedPromise:Promise.reject(byobReaderBrandCheckException("closed"))}cancel(e){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?Promise.reject(readerLockException("cancel")):ReadableStreamReaderGenericCancel(this,e):Promise.reject(byobReaderBrandCheckException("cancel"))}read(e){return IsReadableStreamBYOBReader(this)?void 0===this._ownerReadableStream?Promise.reject(readerLockException("read from")):ArrayBuffer.isView(e)?!0===IsDetachedBuffer(e.buffer)?Promise.reject(new TypeError("Cannot read into a view onto a detached ArrayBuffer")):0===e.byteLength?Promise.reject(new TypeError("view must have non-zero byteLength")):ReadableStreamBYOBReaderRead(this,e):Promise.reject(new TypeError("view must be an array buffer view")):Promise.reject(byobReaderBrandCheckException("read"))}releaseLock(){if(!IsReadableStreamBYOBReader(this))throw byobReaderBrandCheckException("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");ReadableStreamReaderGenericRelease(this)}}}class ReadableStreamDefaultController{constructor(){throw new TypeError}get desiredSize(){if(!1===IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException("desiredSize");return ReadableStreamDefaultControllerGetDesiredSize(this)}close(){if(!1===IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException("close");if(!1===ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw new TypeError("The stream is not in a state that permits close");ReadableStreamDefaultControllerClose(this)}enqueue(e){if(!1===IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException("enqueue");if(!1===ReadableStreamDefaultControllerCanCloseOrEnqueue(this))throw new TypeError("The stream is not in a state that permits enqueue");return ReadableStreamDefaultControllerEnqueue(this,e)}error(e){if(!1===IsReadableStreamDefaultController(this))throw defaultControllerBrandCheckException("error");const r=this._controlledReadableStream;if("readable"!==r._state)throw new TypeError(`The stream is ${r._state} and so cannot be errored`);ReadableStreamDefaultControllerError(this,e)}[CancelSteps](e){return ResetQueue(this),this._cancelAlgorithm(e)}[PullSteps](){const e=this._controlledReadableStream;if(this._queue.length>0){const r=DequeueValue(this);return!0===this._closeRequested&&0===this._queue.length?ReadableStreamClose(e):ReadableStreamDefaultControllerCallPullIfNeeded(this),Promise.resolve(CreateIterResultObject(r,!1))}const r=ReadableStreamAddReadRequest(e);return ReadableStreamDefaultControllerCallPullIfNeeded(this),r}}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("ReadableStreamBYOBRequest cannot be used directly")}get view(){if(!1===IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("view");return this._view}respond(e){if(!1===IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!0===IsDetachedBuffer(this._view.buffer))throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!1===IsReadableStreamBYOBRequest(this))throw byobRequestBrandCheckException("respond");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");if(!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(!0===IsDetachedBuffer(e.buffer))throw new TypeError("The supplied view's buffer has been detached and so cannot be used as a response");ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,e)}}class ReadableByteStreamController{constructor(){throw new TypeError("ReadableByteStreamController constructor cannot be used directly")}get byobRequest(){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("byobRequest");if(void 0===this._byobRequest&&this._pendingPullIntos.length>0){const e=this._pendingPullIntos[0],r=new Uint8Array(e.buffer,e.byteOffset+e.bytesFilled,e.byteLength-e.bytesFilled),t=Object.create(ReadableStreamBYOBRequest.prototype);SetUpReadableStreamBYOBRequest(t,this,r),this._byobRequest=t}return this._byobRequest}get desiredSize(){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("desiredSize");return ReadableByteStreamControllerGetDesiredSize(this)}close(){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("close");if(!0===this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if("readable"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);ReadableByteStreamControllerClose(this)}enqueue(e){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("enqueue");if(!0===this._closeRequested)throw new TypeError("stream is closed or draining");const r=this._controlledReadableByteStream._state;if("readable"!==r)throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be enqueued to`);if(!ArrayBuffer.isView(e))throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");if(!0===IsDetachedBuffer(e.buffer))throw new TypeError("Cannot enqueue a view onto a detached ArrayBuffer");ReadableByteStreamControllerEnqueue(this,e)}error(e){if(!1===IsReadableByteStreamController(this))throw byteStreamControllerBrandCheckException("error");const r=this._controlledReadableByteStream;if("readable"!==r._state)throw new TypeError(`The stream is ${r._state} and so cannot be errored`);ReadableByteStreamControllerError(this,e)}[CancelSteps](e){return this._pendingPullIntos.length>0&&(this._pendingPullIntos[0].bytesFilled=0),ResetQueue(this),this._cancelAlgorithm(e)}[PullSteps](){const e=this._controlledReadableByteStream;if(this._queueTotalSize>0){const e=this._queue.shift();this._queueTotalSize-=e.byteLength,ReadableByteStreamControllerHandleQueueDrain(this);let r;try{r=new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}catch(e){return Promise.reject(e)}return Promise.resolve(CreateIterResultObject(r,!1))}const r=this._autoAllocateChunkSize;if(void 0!==r){let e;try{e=new ArrayBuffer(r)}catch(e){return Promise.reject(e)}const t={buffer:e,byteOffset:0,byteLength:r,bytesFilled:0,elementSize:1,ctor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(t)}const t=ReadableStreamAddReadRequest(e);return ReadableByteStreamControllerCallPullIfNeeded(this),t}}

},{"./helpers.js":10,"./queue-with-sizes.js":11,"./utils.js":14,"./writable-stream.js":15,"better-assert":16}],13:[function(_dereq_,module,exports){
"use strict";function CreateTransformStream(r,e,t,a=1,o=(()=>1),n=0,l=(()=>1)){const s=Object.create(TransformStream.prototype);let m;InitializeTransformStream(s,new Promise(r=>{m=r}),a,o,n,l),SetUpTransformStreamDefaultController(s,Object.create(TransformStreamDefaultController.prototype),e,t);const i=r();return m(i),s}function InitializeTransformStream(r,e,t,a,o,n){function startAlgorithm(){return e}r._writable=CreateWritableStream(startAlgorithm,function writeAlgorithm(e){return TransformStreamDefaultSinkWriteAlgorithm(r,e)},function closeAlgorithm(){return TransformStreamDefaultSinkCloseAlgorithm(r)},function abortAlgorithm(){return TransformStreamDefaultSinkAbortAlgorithm(r)},t,a),r._readable=CreateReadableStream(startAlgorithm,function pullAlgorithm(){return TransformStreamDefaultSourcePullAlgorithm(r)},function cancelAlgorithm(e){return TransformStreamErrorWritableAndUnblockWrite(r,e),Promise.resolve()},o,n),r._backpressure=void 0,r._backpressureChangePromise=void 0,r._backpressureChangePromise_resolve=void 0,TransformStreamSetBackpressure(r,!0),r._transformStreamController=void 0}function IsTransformStream(r){return!!typeIsObject(r)&&!!Object.prototype.hasOwnProperty.call(r,"_transformStreamController")}function TransformStreamError(r,e){verbose("TransformStreamError()"),"readable"===r._readable._state&&ReadableStreamDefaultControllerError(r._readable._readableStreamController,e),TransformStreamErrorWritableAndUnblockWrite(r,e)}function TransformStreamErrorWritableAndUnblockWrite(r,e){WritableStreamDefaultControllerErrorIfNeeded(r._writable._writableStreamController,e),!0===r._backpressure&&TransformStreamSetBackpressure(r,!1)}function TransformStreamSetBackpressure(r,e){verbose(`TransformStreamSetBackpressure() [backpressure = ${e}]`),void 0!==r._backpressureChangePromise&&r._backpressureChangePromise_resolve(),r._backpressureChangePromise=new Promise(e=>{r._backpressureChangePromise_resolve=e}),r._backpressure=e}function IsTransformStreamDefaultController(r){return!!typeIsObject(r)&&!!Object.prototype.hasOwnProperty.call(r,"_controlledTransformStream")}function SetUpTransformStreamDefaultController(r,e,t,a){e._controlledTransformStream=r,r._transformStreamController=e,e._transformAlgorithm=t,e._flushAlgorithm=a}function SetUpTransformStreamDefaultControllerFromTransformer(r,e){const t=Object.create(TransformStreamDefaultController.prototype);let a=r=>{try{return TransformStreamDefaultControllerEnqueue(t,r),Promise.resolve()}catch(r){return Promise.reject(r)}};const o=e.transform;if(void 0!==o){if("function"!=typeof o)throw new TypeError("transform is not a method");a=(a=>PromiseCall(o,e,[a,t]).catch(e=>{throw TransformStreamError(r,e),e}))}const n=CreateAlgorithmFromUnderlyingMethod(e,"flush",0,[t]);SetUpTransformStreamDefaultController(r,t,a,n)}function TransformStreamDefaultControllerEnqueue(r,e){verbose("TransformStreamDefaultControllerEnqueue()");const t=r._controlledTransformStream,a=t._readable._readableStreamController;if(!1===ReadableStreamDefaultControllerCanCloseOrEnqueue(a))throw new TypeError("Readable side is not in a state that permits enqueue");try{ReadableStreamDefaultControllerEnqueue(a,e)}catch(r){throw TransformStreamErrorWritableAndUnblockWrite(t,r),t._readable._storedError}ReadableStreamDefaultControllerHasBackpressure(a)!==t._backpressure&&TransformStreamSetBackpressure(t,!0)}function TransformStreamDefaultControllerError(r,e){TransformStreamError(r._controlledTransformStream,e)}function TransformStreamDefaultControllerTerminate(r){verbose("TransformStreamDefaultControllerTerminate()");const e=r._controlledTransformStream,t=e._readable._readableStreamController;!0===ReadableStreamDefaultControllerCanCloseOrEnqueue(t)&&ReadableStreamDefaultControllerClose(t),TransformStreamErrorWritableAndUnblockWrite(e,new TypeError("TransformStream terminated"))}function TransformStreamDefaultSinkWriteAlgorithm(r,e){verbose("TransformStreamDefaultSinkWriteAlgorithm()");const t=r._transformStreamController;return!0===r._backpressure?r._backpressureChangePromise.then(()=>{const a=r._writable;if("erroring"===a._state)throw a._storedError;return t._transformAlgorithm(e)}):t._transformAlgorithm(e)}function TransformStreamDefaultSinkAbortAlgorithm(r){return TransformStreamError(r,new TypeError("Writable side aborted")),Promise.resolve()}function TransformStreamDefaultSinkCloseAlgorithm(r){verbose("TransformStreamDefaultSinkCloseAlgorithm()");const e=r._readable;return r._transformStreamController._flushAlgorithm().then(()=>{if("errored"===e._state)throw e._storedError;const r=e._readableStreamController;!0===ReadableStreamDefaultControllerCanCloseOrEnqueue(r)&&ReadableStreamDefaultControllerClose(r)}).catch(t=>{throw TransformStreamError(r,t),e._storedError})}function TransformStreamDefaultSourcePullAlgorithm(r){return verbose("TransformStreamDefaultSourcePullAlgorithm()"),TransformStreamSetBackpressure(r,!1),r._backpressureChangePromise}function defaultControllerBrandCheckException(r){return new TypeError(`TransformStreamDefaultController.prototype.${r} can only be used on a TransformStreamDefaultController`)}function streamBrandCheckException(r){return new TypeError(`TransformStream.prototype.${r} can only be used on a TransformStream`)}const assert=_dereq_("better-assert"),verbose=_dereq_("debug")("streams:transform-stream:verbose");var _require=_dereq_("./helpers.js");const InvokeOrNoop=_require.InvokeOrNoop,CreateAlgorithmFromUnderlyingMethod=_require.CreateAlgorithmFromUnderlyingMethod,PromiseCall=_require.PromiseCall,typeIsObject=_require.typeIsObject,ValidateAndNormalizeHighWaterMark=_require.ValidateAndNormalizeHighWaterMark,IsNonNegativeNumber=_require.IsNonNegativeNumber,MakeSizeAlgorithmFromSizeFunction=_require.MakeSizeAlgorithmFromSizeFunction;var _require2=_dereq_("./readable-stream.js");const CreateReadableStream=_require2.CreateReadableStream,ReadableStreamDefaultControllerClose=_require2.ReadableStreamDefaultControllerClose,ReadableStreamDefaultControllerEnqueue=_require2.ReadableStreamDefaultControllerEnqueue,ReadableStreamDefaultControllerError=_require2.ReadableStreamDefaultControllerError,ReadableStreamDefaultControllerGetDesiredSize=_require2.ReadableStreamDefaultControllerGetDesiredSize,ReadableStreamDefaultControllerHasBackpressure=_require2.ReadableStreamDefaultControllerHasBackpressure,ReadableStreamDefaultControllerCanCloseOrEnqueue=_require2.ReadableStreamDefaultControllerCanCloseOrEnqueue;var _require3=_dereq_("./writable-stream.js");const CreateWritableStream=_require3.CreateWritableStream,WritableStreamDefaultControllerErrorIfNeeded=_require3.WritableStreamDefaultControllerErrorIfNeeded;class TransformStream{constructor(r={},e={},t={}){if(void 0!==r.readableType)throw new RangeError("Invalid readable type specified");if(void 0!==r.writableType)throw new RangeError("Invalid writable type specified");const a=e.size,o=MakeSizeAlgorithmFromSizeFunction(a);let n=e.highWaterMark;void 0===n&&(n=1),n=ValidateAndNormalizeHighWaterMark(n);const l=t.size,s=MakeSizeAlgorithmFromSizeFunction(l);let m=t.highWaterMark;void 0===m&&(m=0),m=ValidateAndNormalizeHighWaterMark(m);let i;InitializeTransformStream(this,new Promise(r=>{i=r}),n,o,m,s),SetUpTransformStreamDefaultControllerFromTransformer(this,r);const u=InvokeOrNoop(r,"start",[this._transformStreamController]);i(u)}get readable(){if(!1===IsTransformStream(this))throw streamBrandCheckException("readable");return this._readable}get writable(){if(!1===IsTransformStream(this))throw streamBrandCheckException("writable");return this._writable}}class TransformStreamDefaultController{constructor(){throw new TypeError("TransformStreamDefaultController instances cannot be created directly")}get desiredSize(){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("desiredSize");const r=this._controlledTransformStream._readable._readableStreamController;return ReadableStreamDefaultControllerGetDesiredSize(r)}enqueue(r){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("enqueue");TransformStreamDefaultControllerEnqueue(this,r)}error(r){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("error");TransformStreamDefaultControllerError(this,r)}terminate(){if(!1===IsTransformStreamDefaultController(this))throw defaultControllerBrandCheckException("terminate");TransformStreamDefaultControllerTerminate(this)}}module.exports={CreateTransformStream:CreateTransformStream,TransformStream:TransformStream};

},{"./helpers.js":10,"./readable-stream.js":12,"./writable-stream.js":15,"better-assert":16,"debug":18}],14:[function(_dereq_,module,exports){
"use strict";const assert=_dereq_("better-assert");exports.rethrowAssertionErrorRejection=(r=>{r&&r.constructor===assert.AssertionError&&setTimeout(()=>{throw r},0)});

},{"better-assert":16}],15:[function(_dereq_,module,exports){
"use strict";function AcquireWritableStreamDefaultWriter(e){return new WritableStreamDefaultWriter(e)}function CreateWritableStream(e,r,t,i,o=1,a=(()=>1)){const l=Object.create(WritableStream.prototype);return InitializeWritableStream(l),SetUpWritableStreamDefaultController(l,Object.create(WritableStreamDefaultController.prototype),e,r,t,i,o,a),l}function InitializeWritableStream(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=[],e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function IsWritableStream(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")}function IsWritableStreamLocked(e){return void 0!==e._writer}function WritableStreamAbort(e,r){const t=e._state;if("closed"===t)return Promise.resolve(void 0);if("errored"===t)return Promise.reject(e._storedError);const i=new TypeError("Requested to abort");if(void 0!==e._pendingAbortRequest)return Promise.reject(i);let o=!1;"erroring"===t&&(o=!0,r=void 0);const a=new Promise((t,i)=>{e._pendingAbortRequest={_resolve:t,_reject:i,_reason:r,_wasAlreadyErroring:o}});return!1===o&&WritableStreamStartErroring(e,i),a}function WritableStreamAddWriteRequest(e){return new Promise((r,t)=>{const i={_resolve:r,_reject:t};e._writeRequests.push(i)})}function WritableStreamDealWithRejection(e,r){verbose("WritableStreamDealWithRejection(stream, %o)",r),"writable"!==e._state?WritableStreamFinishErroring(e):WritableStreamStartErroring(e,r)}function WritableStreamStartErroring(e,r){verbose("WritableStreamStartErroring(stream, %o)",r);const t=e._writableStreamController;e._state="erroring",e._storedError=r;const i=e._writer;void 0!==i&&WritableStreamDefaultWriterEnsureReadyPromiseRejected(i,r),!1===WritableStreamHasOperationMarkedInFlight(e)&&!0===t._started&&WritableStreamFinishErroring(e)}function WritableStreamFinishErroring(e){verbose("WritableStreamFinishErroring()"),e._state="errored",e._writableStreamController[ErrorSteps]();const r=e._storedError;for(const t of e._writeRequests)t._reject(r);if(e._writeRequests=[],void 0===e._pendingAbortRequest)return void WritableStreamRejectCloseAndClosedPromiseIfNeeded(e);const t=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,!0===t._wasAlreadyErroring)return t._reject(r),void WritableStreamRejectCloseAndClosedPromiseIfNeeded(e);e._writableStreamController[AbortSteps](t._reason).then(()=>{t._resolve(),WritableStreamRejectCloseAndClosedPromiseIfNeeded(e)},r=>{t._reject(r),WritableStreamRejectCloseAndClosedPromiseIfNeeded(e)})}function WritableStreamFinishInFlightWrite(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}function WritableStreamFinishInFlightWriteWithError(e,r){e._inFlightWriteRequest._reject(r),e._inFlightWriteRequest=void 0,WritableStreamDealWithRejection(e,r)}function WritableStreamFinishInFlightClose(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,"erroring"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const r=e._writer;void 0!==r&&defaultWriterClosedPromiseResolve(r)}function WritableStreamFinishInFlightCloseWithError(e,r){e._inFlightCloseRequest._reject(r),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(r),e._pendingAbortRequest=void 0),WritableStreamDealWithRejection(e,r)}function WritableStreamCloseQueuedOrInFlight(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function WritableStreamHasOperationMarkedInFlight(e){return void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest?(verbose("WritableStreamHasOperationMarkedInFlight() is false"),!1):(verbose("WritableStreamHasOperationMarkedInFlight() is true"),!0)}function WritableStreamMarkCloseRequestInFlight(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0}function WritableStreamMarkFirstWriteRequestInFlight(e){e._inFlightWriteRequest=e._writeRequests.shift()}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(e){verbose("WritableStreamRejectCloseAndClosedPromiseIfNeeded()"),void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const r=e._writer;void 0!==r&&(defaultWriterClosedPromiseReject(r,e._storedError),r._closedPromise.catch(()=>{}))}function WritableStreamUpdateBackpressure(e,r){const t=e._writer;void 0!==t&&r!==e._backpressure&&(!0===r?defaultWriterReadyPromiseReset(t):defaultWriterReadyPromiseResolve(t)),e._backpressure=r}function IsWritableStreamDefaultWriter(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")}function WritableStreamDefaultWriterAbort(e,r){return WritableStreamAbort(e._ownerWritableStream,r)}function WritableStreamDefaultWriterClose(e){const r=e._ownerWritableStream,t=r._state;if("closed"===t||"errored"===t)return Promise.reject(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const i=new Promise((e,t)=>{const i={_resolve:e,_reject:t};r._closeRequest=i});return!0===r._backpressure&&"writable"===t&&defaultWriterReadyPromiseResolve(e),WritableStreamDefaultControllerClose(r._writableStreamController),i}function WritableStreamDefaultWriterCloseWithErrorPropagation(e){const r=e._ownerWritableStream,t=r._state;return!0===WritableStreamCloseQueuedOrInFlight(r)||"closed"===t?Promise.resolve():"errored"===t?Promise.reject(r._storedError):WritableStreamDefaultWriterClose(e)}function WritableStreamDefaultWriterEnsureClosedPromiseRejected(e,r){"pending"===e._closedPromiseState?defaultWriterClosedPromiseReject(e,r):defaultWriterClosedPromiseResetToRejected(e,r),e._closedPromise.catch(()=>{})}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(e,r){verbose("WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)",r),"pending"===e._readyPromiseState?defaultWriterReadyPromiseReject(e,r):defaultWriterReadyPromiseResetToRejected(e,r),e._readyPromise.catch(()=>{})}function WritableStreamDefaultWriterGetDesiredSize(e){const r=e._ownerWritableStream,t=r._state;return"errored"===t||"erroring"===t?null:"closed"===t?0:WritableStreamDefaultControllerGetDesiredSize(r._writableStreamController)}function WritableStreamDefaultWriterRelease(e){const r=e._ownerWritableStream,t=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");WritableStreamDefaultWriterEnsureReadyPromiseRejected(e,t),WritableStreamDefaultWriterEnsureClosedPromiseRejected(e,t),r._writer=void 0,e._ownerWritableStream=void 0}function WritableStreamDefaultWriterWrite(e,r){const t=e._ownerWritableStream,i=t._writableStreamController,o=WritableStreamDefaultControllerGetChunkSize(i,r);if(t!==e._ownerWritableStream)return Promise.reject(defaultWriterLockException("write to"));const a=t._state;if("errored"===a)return Promise.reject(t._storedError);if(!0===WritableStreamCloseQueuedOrInFlight(t)||"closed"===a)return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===a)return Promise.reject(t._storedError);const l=WritableStreamAddWriteRequest(t);return WritableStreamDefaultControllerWrite(i,r,o),l}function IsWritableStreamDefaultController(e){return!!typeIsObject(e)&&!!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream")}function SetUpWritableStreamDefaultController(e,r,t,i,o,a,l,s){r._controlledWritableStream=e,e._writableStreamController=r,r._queue=void 0,r._queueTotalSize=void 0,ResetQueue(r),r._started=!1,r._strategySizeAlgorithm=s,r._strategyHWM=l,r._writeAlgorithm=i,r._closeAlgorithm=o,r._abortAlgorithm=a;const n=WritableStreamDefaultControllerGetBackpressure(r);WritableStreamUpdateBackpressure(e,n);const d=t();Promise.resolve(d).then(()=>{r._started=!0,WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)},t=>{r._started=!0,WritableStreamDealWithRejection(e,t)}).catch(rethrowAssertionErrorRejection)}function SetUpWritableStreamDefaultControllerFromUnderlyingSink(e,r,t,i){const o=Object.create(WritableStreamDefaultController.prototype),a=CreateAlgorithmFromUnderlyingMethod(r,"write",1,[o]),l=CreateAlgorithmFromUnderlyingMethod(r,"close",0,[]),s=CreateAlgorithmFromUnderlyingMethod(r,"abort",1,[]);SetUpWritableStreamDefaultController(e,o,function startAlgorithm(){return InvokeOrNoop(r,"start",[o])},a,l,s,t,i)}function WritableStreamDefaultControllerClose(e){EnqueueValueWithSize(e,"close",0),WritableStreamDefaultControllerAdvanceQueueIfNeeded(e)}function WritableStreamDefaultControllerGetChunkSize(e,r){try{return e._strategySizeAlgorithm(r)}catch(r){return WritableStreamDefaultControllerErrorIfNeeded(e,r),1}}function WritableStreamDefaultControllerGetDesiredSize(e){return e._strategyHWM-e._queueTotalSize}function WritableStreamDefaultControllerWrite(e,r,t){const i={chunk:r};try{EnqueueValueWithSize(e,i,t)}catch(r){return void WritableStreamDefaultControllerErrorIfNeeded(e,r)}const o=e._controlledWritableStream;!1===WritableStreamCloseQueuedOrInFlight(o)&&"writable"===o._state&&WritableStreamUpdateBackpressure(o,WritableStreamDefaultControllerGetBackpressure(e)),WritableStreamDefaultControllerAdvanceQueueIfNeeded(e)}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(e){verbose("WritableStreamDefaultControllerAdvanceQueueIfNeeded()");const r=e._controlledWritableStream;if(!1===e._started)return;if(void 0!==r._inFlightWriteRequest)return;const t=r._state;if("closed"===t||"errored"===t)return;if("erroring"===t)return void WritableStreamFinishErroring(r);if(0===e._queue.length)return;const i=PeekQueueValue(e);"close"===i?WritableStreamDefaultControllerProcessClose(e):WritableStreamDefaultControllerProcessWrite(e,i.chunk)}function WritableStreamDefaultControllerErrorIfNeeded(e,r){"writable"===e._controlledWritableStream._state&&WritableStreamDefaultControllerError(e,r)}function WritableStreamDefaultControllerProcessClose(e){const r=e._controlledWritableStream;WritableStreamMarkCloseRequestInFlight(r),DequeueValue(e),e._closeAlgorithm().then(()=>{WritableStreamFinishInFlightClose(r)},e=>{WritableStreamFinishInFlightCloseWithError(r,e)}).catch(rethrowAssertionErrorRejection)}function WritableStreamDefaultControllerProcessWrite(e,r){const t=e._controlledWritableStream;WritableStreamMarkFirstWriteRequestInFlight(t),e._writeAlgorithm(r).then(()=>{WritableStreamFinishInFlightWrite(t);const r=t._state;if(DequeueValue(e),!1===WritableStreamCloseQueuedOrInFlight(t)&&"writable"===r){const r=WritableStreamDefaultControllerGetBackpressure(e);WritableStreamUpdateBackpressure(t,r)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(e)},e=>{WritableStreamFinishInFlightWriteWithError(t,e)}).catch(rethrowAssertionErrorRejection)}function WritableStreamDefaultControllerGetBackpressure(e){return WritableStreamDefaultControllerGetDesiredSize(e)<=0}function WritableStreamDefaultControllerError(e,r){WritableStreamStartErroring(e._controlledWritableStream,r)}function streamBrandCheckException(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function defaultWriterBrandCheckException(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(e){e._closedPromise=new Promise((r,t)=>{e._closedPromise_resolve=r,e._closedPromise_reject=t,e._closedPromiseState="pending"})}function defaultWriterClosedPromiseInitializeAsRejected(e,r){e._closedPromise=Promise.reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function defaultWriterClosedPromiseInitializeAsResolved(e){e._closedPromise=Promise.resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}function defaultWriterClosedPromiseReject(e,r){e._closedPromise_reject(r),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected"}function defaultWriterClosedPromiseResetToRejected(e,r){e._closedPromise=Promise.reject(r),e._closedPromiseState="rejected"}function defaultWriterClosedPromiseResolve(e){e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved"}function defaultWriterReadyPromiseInitialize(e){verbose("defaultWriterReadyPromiseInitialize()"),e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(e,r){verbose("defaultWriterReadyPromiseInitializeAsRejected(writer, %o)",r),e._readyPromise=Promise.reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function defaultWriterReadyPromiseInitializeAsResolved(e){verbose("defaultWriterReadyPromiseInitializeAsResolved()"),e._readyPromise=Promise.resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}function defaultWriterReadyPromiseReject(e,r){verbose("defaultWriterReadyPromiseReject(writer, %o)",r),e._readyPromise_reject(r),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected"}function defaultWriterReadyPromiseReset(e){verbose("defaultWriterReadyPromiseReset()"),e._readyPromise=new Promise((r,t)=>{e._readyPromise_resolve=r,e._readyPromise_reject=t}),e._readyPromiseState="pending"}function defaultWriterReadyPromiseResetToRejected(e,r){verbose("defaultWriterReadyPromiseResetToRejected(writer, %o)",r),e._readyPromise=Promise.reject(r),e._readyPromiseState="rejected"}function defaultWriterReadyPromiseResolve(e){verbose("defaultWriterReadyPromiseResolve()"),e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled"}const assert=_dereq_("better-assert"),verbose=_dereq_("debug")("streams:writable-stream:verbose");var _require=_dereq_("./helpers.js");const CreateAlgorithmFromUnderlyingMethod=_require.CreateAlgorithmFromUnderlyingMethod,InvokeOrNoop=_require.InvokeOrNoop,ValidateAndNormalizeHighWaterMark=_require.ValidateAndNormalizeHighWaterMark,IsNonNegativeNumber=_require.IsNonNegativeNumber,MakeSizeAlgorithmFromSizeFunction=_require.MakeSizeAlgorithmFromSizeFunction,typeIsObject=_require.typeIsObject;var _require2=_dereq_("./utils.js");const rethrowAssertionErrorRejection=_require2.rethrowAssertionErrorRejection;var _require3=_dereq_("./queue-with-sizes.js");const DequeueValue=_require3.DequeueValue,EnqueueValueWithSize=_require3.EnqueueValueWithSize,PeekQueueValue=_require3.PeekQueueValue,ResetQueue=_require3.ResetQueue,AbortSteps=Symbol("[[AbortSteps]]"),ErrorSteps=Symbol("[[ErrorSteps]]");class WritableStream{constructor(e={},{size:r,highWaterMark:t=1}={}){if(InitializeWritableStream(this),void 0!==e.type)throw new RangeError("Invalid type is specified");const i=MakeSizeAlgorithmFromSizeFunction(r);SetUpWritableStreamDefaultControllerFromUnderlyingSink(this,e,t=ValidateAndNormalizeHighWaterMark(t),i)}get locked(){if(!1===IsWritableStream(this))throw streamBrandCheckException("locked");return IsWritableStreamLocked(this)}abort(e){return!1===IsWritableStream(this)?Promise.reject(streamBrandCheckException("abort")):!0===IsWritableStreamLocked(this)?Promise.reject(new TypeError("Cannot abort a stream that already has a writer")):WritableStreamAbort(this,e)}getWriter(){if(!1===IsWritableStream(this))throw streamBrandCheckException("getWriter");return AcquireWritableStreamDefaultWriter(this)}}module.exports={AcquireWritableStreamDefaultWriter:AcquireWritableStreamDefaultWriter,CreateWritableStream:CreateWritableStream,IsWritableStream:IsWritableStream,IsWritableStreamLocked:IsWritableStreamLocked,WritableStream:WritableStream,WritableStreamAbort:WritableStreamAbort,WritableStreamDefaultControllerErrorIfNeeded:WritableStreamDefaultControllerErrorIfNeeded,WritableStreamDefaultWriterCloseWithErrorPropagation:WritableStreamDefaultWriterCloseWithErrorPropagation,WritableStreamDefaultWriterRelease:WritableStreamDefaultWriterRelease,WritableStreamDefaultWriterWrite:WritableStreamDefaultWriterWrite,WritableStreamCloseQueuedOrInFlight:WritableStreamCloseQueuedOrInFlight};class WritableStreamDefaultWriter{constructor(e){if(!1===IsWritableStream(e))throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");if(!0===IsWritableStreamLocked(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const r=e._state;if("writable"===r)!1===WritableStreamCloseQueuedOrInFlight(e)&&!0===e._backpressure?defaultWriterReadyPromiseInitialize(this):defaultWriterReadyPromiseInitializeAsResolved(this),defaultWriterClosedPromiseInitialize(this);else if("erroring"===r)defaultWriterReadyPromiseInitializeAsRejected(this,e._storedError),this._readyPromise.catch(()=>{}),defaultWriterClosedPromiseInitialize(this);else if("closed"===r)defaultWriterReadyPromiseInitializeAsResolved(this),defaultWriterClosedPromiseInitializeAsResolved(this);else{const r=e._storedError;defaultWriterReadyPromiseInitializeAsRejected(this,r),this._readyPromise.catch(()=>{}),defaultWriterClosedPromiseInitializeAsRejected(this,r),this._closedPromise.catch(()=>{})}}get closed(){return!1===IsWritableStreamDefaultWriter(this)?Promise.reject(defaultWriterBrandCheckException("closed")):this._closedPromise}get desiredSize(){if(!1===IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("desiredSize");if(void 0===this._ownerWritableStream)throw defaultWriterLockException("desiredSize");return WritableStreamDefaultWriterGetDesiredSize(this)}get ready(){return!1===IsWritableStreamDefaultWriter(this)?Promise.reject(defaultWriterBrandCheckException("ready")):this._readyPromise}abort(e){return!1===IsWritableStreamDefaultWriter(this)?Promise.reject(defaultWriterBrandCheckException("abort")):void 0===this._ownerWritableStream?Promise.reject(defaultWriterLockException("abort")):WritableStreamDefaultWriterAbort(this,e)}close(){if(!1===IsWritableStreamDefaultWriter(this))return Promise.reject(defaultWriterBrandCheckException("close"));const e=this._ownerWritableStream;return void 0===e?Promise.reject(defaultWriterLockException("close")):!0===WritableStreamCloseQueuedOrInFlight(e)?Promise.reject(new TypeError("cannot close an already-closing stream")):WritableStreamDefaultWriterClose(this)}releaseLock(){if(!1===IsWritableStreamDefaultWriter(this))throw defaultWriterBrandCheckException("releaseLock");void 0!==this._ownerWritableStream&&WritableStreamDefaultWriterRelease(this)}write(e){return!1===IsWritableStreamDefaultWriter(this)?Promise.reject(defaultWriterBrandCheckException("write")):void 0===this._ownerWritableStream?Promise.reject(defaultWriterLockException("write to")):WritableStreamDefaultWriterWrite(this,e)}}class WritableStreamDefaultController{constructor(){throw new TypeError("WritableStreamDefaultController cannot be constructed explicitly")}error(e){if(!1===IsWritableStreamDefaultController(this))throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");"writable"===this._controlledWritableStream._state&&WritableStreamDefaultControllerError(this,e)}[AbortSteps](e){return this._abortAlgorithm(e)}[ErrorSteps](){ResetQueue(this)}}

},{"./helpers.js":10,"./queue-with-sizes.js":11,"./utils.js":14,"better-assert":16,"debug":18}],16:[function(_dereq_,module,exports){
(function (process){
function assert(e){if(!e){var r=callsite(),s=r[1],t=s.getFileName(),i=s.getLineNumber(),n=(n=fs.readFileSync(t,"utf8")).split("\n")[i-1].match(/assert\((.*)\)/)[1];throw new AssertionError({message:n,stackStartFunction:r[0].getFunction()})}}var AssertionError=_dereq_("assert").AssertionError,callsite=_dereq_("callsite"),fs=_dereq_("fs");module.exports=process.env.NO_ASSERT?function(){}:assert;

}).call(this,_dereq_('_process'))

},{"_process":4,"assert":2,"callsite":17,"fs":3}],17:[function(_dereq_,module,exports){
module.exports=function(){var r=Error.prepareStackTrace;Error.prepareStackTrace=function(r,e){return e};var e=new Error;Error.captureStackTrace(e,arguments.callee);var a=e.stack;return Error.prepareStackTrace=r,a};

},{}],18:[function(_dereq_,module,exports){
(function (process){
function useColors(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))}function formatArgs(e){var o=this.useColors;if(e[0]=(o?"%c":"")+this.namespace+(o?" %c":" ")+e[0]+(o?"%c ":" ")+"+"+exports.humanize(this.diff),o){var C="color: "+this.color;e.splice(1,0,C,"color: inherit");var t=0,r=0;e[0].replace(/%[a-zA-Z%]/g,function(e){"%%"!==e&&(t++,"%c"===e&&(r=t))}),e.splice(r,0,C)}}function log(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}function save(e){try{null==e?exports.storage.removeItem("debug"):exports.storage.debug=e}catch(e){}}function load(){var e;try{e=exports.storage.debug}catch(e){}return!e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG),e}function localstorage(){try{return window.localStorage}catch(e){}}exports=module.exports=_dereq_("./debug"),exports.log=log,exports.formatArgs=formatArgs,exports.save=save,exports.load=load,exports.useColors=useColors,exports.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:localstorage(),exports.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],exports.formatters.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}},exports.enable(load());

}).call(this,_dereq_('_process'))

},{"./debug":19,"_process":4}],19:[function(_dereq_,module,exports){
function selectColor(e){var r,t=0;for(r in e)t=(t<<5)-t+e.charCodeAt(r),t|=0;return exports.colors[Math.abs(t)%exports.colors.length]}function createDebug(e){function debug(){if(debug.enabled){var e=debug,t=+new Date,s=t-(r||t);e.diff=s,e.prev=r,e.curr=t,r=t;for(var o=new Array(arguments.length),n=0;n<o.length;n++)o[n]=arguments[n];o[0]=exports.coerce(o[0]),"string"!=typeof o[0]&&o.unshift("%O");var a=0;o[0]=o[0].replace(/%([a-zA-Z%])/g,function(r,t){if("%%"===r)return r;a++;var s=exports.formatters[t];if("function"==typeof s){var n=o[a];r=s.call(e,n),o.splice(a,1),a--}return r}),exports.formatArgs.call(e,o),(debug.log||exports.log||console.log.bind(console)).apply(e,o)}}var r;return debug.namespace=e,debug.enabled=exports.enabled(e),debug.useColors=exports.useColors(),debug.color=selectColor(e),debug.destroy=destroy,"function"==typeof exports.init&&exports.init(debug),exports.instances.push(debug),debug}function destroy(){var e=exports.instances.indexOf(this);return-1!==e&&(exports.instances.splice(e,1),!0)}function enable(e){exports.save(e),exports.names=[],exports.skips=[];var r,t=("string"==typeof e?e:"").split(/[\s,]+/),s=t.length;for(r=0;r<s;r++)t[r]&&("-"===(e=t[r].replace(/\*/g,".*?"))[0]?exports.skips.push(new RegExp("^"+e.substr(1)+"$")):exports.names.push(new RegExp("^"+e+"$")));for(r=0;r<exports.instances.length;r++){var o=exports.instances[r];o.enabled=exports.enabled(o.namespace)}}function disable(){exports.enable("")}function enabled(e){if("*"===e[e.length-1])return!0;var r,t;for(r=0,t=exports.skips.length;r<t;r++)if(exports.skips[r].test(e))return!1;for(r=0,t=exports.names.length;r<t;r++)if(exports.names[r].test(e))return!0;return!1}function coerce(e){return e instanceof Error?e.stack||e.message:e}exports=module.exports=createDebug.debug=createDebug.default=createDebug,exports.coerce=coerce,exports.disable=disable,exports.enable=enable,exports.enabled=enabled,exports.humanize=_dereq_("ms"),exports.instances=[],exports.names=[],exports.skips=[],exports.formatters={};

},{"ms":20}],20:[function(_dereq_,module,exports){
function parse(e){if(!((e=String(e)).length>100)){var r=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);if(r){var a=parseFloat(r[1]);switch((r[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return a*y;case"days":case"day":case"d":return a*d;case"hours":case"hour":case"hrs":case"hr":case"h":return a*h;case"minutes":case"minute":case"mins":case"min":case"m":return a*m;case"seconds":case"second":case"secs":case"sec":case"s":return a*s;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return a;default:return}}}}function fmtShort(e){return e>=d?Math.round(e/d)+"d":e>=h?Math.round(e/h)+"h":e>=m?Math.round(e/m)+"m":e>=s?Math.round(e/s)+"s":e+"ms"}function fmtLong(e){return plural(e,d,"day")||plural(e,h,"hour")||plural(e,m,"minute")||plural(e,s,"second")||e+" ms"}function plural(s,e,r){if(!(s<e))return s<1.5*e?Math.floor(s/e)+" "+r:Math.ceil(s/e)+" "+r+"s"}var s=1e3,m=60*s,h=60*m,d=24*h,y=365.25*d;module.exports=function(s,e){e=e||{};var r=typeof s;if("string"===r&&s.length>0)return parse(s);if("number"===r&&!1===isNaN(s))return e.long?fmtLong(s):fmtShort(s);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(s))};

},{}]},{},[1])(1)
});
//# sourceMappingURL=polyfill.min.js.map
