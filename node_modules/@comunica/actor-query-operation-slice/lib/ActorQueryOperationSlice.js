"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bus_query_operation_1 = require("@comunica/bus-query-operation");
/**
 * A comunica Slice Query Operation Actor.
 */
class ActorQueryOperationSlice extends bus_query_operation_1.ActorQueryOperationTypedMediated {
    constructor(args) {
        super(args, 'slice');
    }
    async testOperation(pattern, context) {
        return true;
    }
    async runOperation(pattern, context) {
        // Resolve the input
        const output = await this.mediatorQueryOperation.mediate({ operation: pattern.input, context });
        const metadata = this.sliceMetadata(output, pattern);
        if (output.type === 'bindings') {
            const bindingsOutput = output;
            const bindingsStream = this.sliceStream(bindingsOutput.bindingsStream, pattern);
            return { type: 'bindings', bindingsStream, metadata, variables: bindingsOutput.variables };
        }
        if (output.type === 'quads') {
            const quadOutput = output;
            const quadStream = this.sliceStream(quadOutput.quadStream, pattern);
            return { type: 'quads', quadStream, metadata };
        }
        throw new Error(`Invalid query output type: Expected 'bindings' or 'quads' but got '${output.type}'`);
    }
    // Slice the stream based on the pattern values
    sliceStream(stream, pattern) {
        const hasLength = !!pattern.length || pattern.length === 0;
        return stream.range(pattern.start, hasLength ? pattern.start + pattern.length - 1 : Infinity);
    }
    // If we find metadata, apply slicing on the total number of items
    sliceMetadata(output, pattern) {
        const hasLength = !!pattern.length || pattern.length === 0;
        return !output.metadata ? undefined : () => output.metadata()
            .then((subMetadata) => {
            let totalItems = subMetadata.totalItems;
            if (isFinite(totalItems)) {
                totalItems = Math.max(0, totalItems - pattern.start);
                if (hasLength) {
                    totalItems = Math.min(totalItems, pattern.length);
                }
            }
            return Object.assign({}, subMetadata, { totalItems });
        });
    }
}
exports.ActorQueryOperationSlice = ActorQueryOperationSlice;
//# sourceMappingURL=ActorQueryOperationSlice.js.map