"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const asynciterator_1 = require("asynciterator");
const asynciterator_promiseproxy_1 = require("asynciterator-promiseproxy");
const rdf_string_1 = require("rdf-string");
const rdf_terms_1 = require("rdf-terms");
const data_model_1 = require("@rdfjs/data-model");
/**
 * An RDF source that executes a quad pattern over a QPF interface and fetches its first page.
 */
class RdfSourceQpf {
    constructor(mediatorMetadata, mediatorMetadataExtract, mediatorRdfDereference, subjectUri, predicateUri, objectUri, graphUri, metadata, context, initialQuads) {
        this.mediatorMetadata = mediatorMetadata;
        this.mediatorMetadataExtract = mediatorMetadataExtract;
        this.mediatorRdfDereference = mediatorRdfDereference;
        this.subjectUri = subjectUri;
        this.predicateUri = predicateUri;
        this.objectUri = objectUri;
        this.graphUri = graphUri;
        this.context = context;
        this.cachedQuads = {};
        const searchForm = this.getSearchForm(metadata);
        if (!searchForm) {
            throw new Error('Illegal state: found no TPF/QPF search form anymore in metadata.');
        }
        this.searchForm = searchForm;
        this.defaultGraph = metadata.defaultGraph ? data_model_1.namedNode(metadata.defaultGraph) : undefined;
        if (initialQuads) {
            let wrappedQuads = asynciterator_1.AsyncIterator.wrap(initialQuads);
            if (this.defaultGraph) {
                wrappedQuads = this.reverseMapQuadsToDefaultGraph(wrappedQuads);
            }
            wrappedQuads.setProperty('metadata', metadata);
            this.cacheQuads(wrappedQuads);
        }
    }
    /**
     * Get a first QPF search form.
     * @param {{[p: string]: any}} metadata A metadata object.
     * @return {ISearchForm} A search form, or null if none could be found.
     */
    getSearchForm(metadata) {
        if (!metadata.searchForms || !metadata.searchForms.values) {
            return undefined;
        }
        // Find a quad pattern or triple pattern search form
        const searchForms = metadata.searchForms;
        // TODO: in the future, a query-based search form getter should be used.
        for (const searchForm of searchForms.values) {
            if (this.graphUri
                && this.subjectUri in searchForm.mappings
                && this.predicateUri in searchForm.mappings
                && this.objectUri in searchForm.mappings
                && this.graphUri in searchForm.mappings
                && Object.keys(searchForm.mappings).length === 4) {
                return searchForm;
            }
            if (this.subjectUri in searchForm.mappings
                && this.predicateUri in searchForm.mappings
                && this.objectUri in searchForm.mappings
                && Object.keys(searchForm.mappings).length === 3) {
                return searchForm;
            }
        }
    }
    /**
     * Create a QPF fragment IRI for the given quad pattern.
     * @param {ISearchForm} searchForm A search form.
     * @param {Term} subject A term or undefined.
     * @param {Term} predicate A term or undefined.
     * @param {Term} object A term or undefined.
     * @param {Term} graph A term or undefined.
     * @return {string} A URI.
     */
    createFragmentUri(searchForm, subject, predicate, object, graph) {
        const entries = {};
        const input = [
            { uri: this.subjectUri, term: subject },
            { uri: this.predicateUri, term: predicate },
            { uri: this.objectUri, term: object },
            { uri: this.graphUri, term: graph },
        ];
        for (const entry of input) {
            if (entry.uri && entry.term) {
                entries[entry.uri] = rdf_string_1.termToString(entry.term);
            }
        }
        return searchForm.getUri(entries);
    }
    match(subject, predicate, object, graph) {
        if (subject instanceof RegExp
            || predicate instanceof RegExp
            || object instanceof RegExp
            || graph instanceof RegExp) {
            throw new Error("RdfSourceQpf does not support matching by regular expressions.");
        }
        // If we are querying the default graph,
        // and the source has an overridden value for the default graph (such as QPF can provide),
        // we override the graph parameter with that value.
        let modifiedGraph = false;
        if (this.defaultGraph && graph && graph.termType === 'DefaultGraph') {
            modifiedGraph = true;
            graph = this.defaultGraph;
        }
        // Try to emit from cache
        const cached = this.getCachedQuads(subject, predicate, object, graph);
        if (cached) {
            return cached;
        }
        const quads = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => {
            let url = await this.createFragmentUri(this.searchForm, subject, predicate, object, graph);
            const rdfDereferenceOutput = await this.mediatorRdfDereference.mediate({ context: this.context, url });
            url = rdfDereferenceOutput.url;
            // Determine the metadata and emit it
            const rdfMetadataOuput = await this.mediatorMetadata.mediate({ context: this.context, url, quads: rdfDereferenceOutput.quads, triples: rdfDereferenceOutput.triples });
            this.mediatorMetadataExtract
                .mediate({ context: this.context, url, metadata: rdfMetadataOuput.metadata })
                .then(({ metadata }) => {
                quads.setProperty('metadata', metadata);
                quads.emit('metadata', metadata);
            });
            // The server is free to send any data in its response (such as metadata),
            // including quads that do not match the given matter.
            // Therefore, we have to filter away all non-matching quads here.
            const actualDefaultGraph = data_model_1.defaultGraph();
            let filteredOutput = asynciterator_1.AsyncIterator.wrap(rdfMetadataOuput.data)
                .filter((quad) => {
                if (rdf_terms_1.matchPattern(quad, subject, predicate, object, graph)) {
                    return true;
                }
                // Special case: if we are querying in the default graph, and we had an overridden default graph,
                // also accept that incoming triples may be defined in the actual default graph
                return modifiedGraph && rdf_terms_1.matchPattern(quad, subject, predicate, object, actualDefaultGraph);
            });
            if (modifiedGraph || !graph) {
                // Reverse-map the overridden default graph back to the actual default graph
                filteredOutput = this.reverseMapQuadsToDefaultGraph(filteredOutput);
            }
            return filteredOutput;
        });
        this.cacheQuads(quads, subject, predicate, object, graph);
        return this.getCachedQuads(subject, predicate, object, graph);
    }
    reverseMapQuadsToDefaultGraph(quads) {
        const actualDefaultGraph = data_model_1.defaultGraph();
        return quads.map((quad) => rdf_terms_1.mapTerms(quad, (term, key) => key === 'graph' && term.equals(this.defaultGraph) ? actualDefaultGraph : term));
    }
    getPatternId(subject, predicate, object, graph) {
        // tslint:disable:object-literal-sort-keys
        return JSON.stringify({
            s: rdf_string_1.termToString(subject),
            p: rdf_string_1.termToString(predicate),
            o: rdf_string_1.termToString(object),
            g: rdf_string_1.termToString(graph),
        });
        // tslint:enable:object-literal-sort-keys
    }
    cacheQuads(quads, subject, predicate, object, graph) {
        const patternId = this.getPatternId(subject, predicate, object, graph);
        this.cachedQuads[patternId] = quads.clone();
    }
    getCachedQuads(subject, predicate, object, graph) {
        const patternId = this.getPatternId(subject, predicate, object, graph);
        let quads = this.cachedQuads[patternId];
        if (quads) {
            const quadsOriginal = quads;
            // Make our iterator lazy to ensure that metadata event is emitted before end event.
            quads = new asynciterator_promiseproxy_1.PromiseProxyIterator(async () => quadsOriginal.clone());
            quadsOriginal.getProperty('metadata', (metadata) => quads.emit('metadata', metadata));
            return quads;
        }
    }
}
exports.RdfSourceQpf = RdfSourceQpf;
//# sourceMappingURL=RdfSourceQpf.js.map